<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>인원 현황판</title>
    <style>
        /* 기본 HTML 요소 스타일 초기화 및 설정 */
        html {
            font-size: 16px; /* 1rem의 기준 설정 */
        }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            padding: 1.25rem; /* 20px */
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
        }

        /* 컨테이너: 최대 너비를 제한하고 중앙 정렬 */
        .container {
            max-width: 50rem; /* 800px */
            margin: 0 auto;
            background-color: #fff;
            padding: 1.5625rem; /* 25px */
            border-radius: 0.625rem; /* 10px */
            box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.1); /* 0 4px 8px */
        }

        /* 제목 및 설명 텍스트 */
        h1 { 
            color: #2c3e50; 
            text-align: center; 
            margin-bottom: 1.5625rem; /* 25px */
            font-size: 1.8em; /* 부모 글꼴 크기의 1.8배 */
        }
        p {
            text-align: center;
            color: #555;
            margin-bottom: 1.25rem; /* 20px */
        }

        /* 텍스트 입력창 */
        textarea { 
            width: calc(100% - 0.625rem * 2); /* 100% - padding * 2 */
            height: 15.625rem; /* 250px */
            margin-bottom: 0.9375rem; /* 15px */
            padding: 0.625rem; /* 10px */
            border: 0.0625rem solid #ccc; /* 1px */
            border-radius: 0.3125rem; /* 5px */
            font-size: 0.95em; /* 부모 글꼴 크기의 0.95배 */
            resize: vertical; /* 세로 크기 조절 허용 */
            box-sizing: border-box; /* 패딩이 너비에 포함되도록 */
        }

        /* 버튼 */
        button { 
            display: block;
            width: 100%;
            padding: 0.75rem 1.25rem; /* 12px 20px */
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 0.3125rem; /* 5px */
            font-size: 1.1em; /* 부모 글꼴 크기의 1.1배 */
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #2980b9;
        }

        /* 결과 표시 영역 - 요일별 섹션 */
        .result-day { 
            margin-top: 1.5625rem; /* 25px */
            padding: 0.9375rem; /* 15px */
            background-color: #ecf0f1;
            border-left: 0.3125rem solid #3498db; /* 5px */
            border-radius: 0.3125rem; /* 5px */
        }
        .result-day h3 { 
            margin-top: 0; 
            color: #2c3e50;
            font-size: 1.4em; /* 부모 글꼴 크기의 1.4배 */
            margin-bottom: 0.625rem; /* 10px */
        }
        .result-day p strong {
            color: #555;
        }

        /* 직원 태그 목록 */
        .employee-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem; /* 8px */
            margin-top: 0.625rem; /* 10px */
            margin-bottom: 0.9375rem; /* 15px */
            padding-left: 0; 
        }
        .employee-tag {
            background-color: #bdc3c7;
            color: #333;
            padding: 0.375rem 0.625rem; /* 6px 10px */
            border-radius: 0.25rem; /* 4px */
            font-size: 0.85em; /* 부모 글꼴 크기의 0.85배 */
            white-space: nowrap; /* 태그가 줄바꿈되지 않도록 */
        }
        .assigned-tag {
            background-color: #2ecc71; /* 배정된 인원 색상 */
            color: white;
        }
        .excluded-tag { /* 휴가/교육/민방위 인원 색상 */
            background-color: #f39c12;
            color: white;
        }
        .remaining-tag {
            background-color: #3498db; /* 남는 인원 색상 */
            color: white;
        }
        .no-one {
            color: #e74c3c;
            font-style: italic;
        }

        /* 버전 정보 */
        .version-info {
            text-align: center;
            margin-top: 1.875rem; /* 30px */
            font-size: 0.8em; /* 부모 글꼴 크기의 0.8배 */
            color: #7f8c8d;
        }

        /* 모바일 최적화를 위한 미디어 쿼리 (특정 해상도에서 추가 조정) */
        @media (max-width: 37.5rem) { /* 600px */
            body {
                padding: 0.9375rem; /* 15px */
            }
            .container {
                padding: 0.9375rem; /* 15px */
            }
            h1 {
                font-size: 1.5em;
            }
            textarea {
                height: 12.5rem; /* 200px */
            }
            button {
                font-size: 1em;
                padding: 0.625rem 0.9375rem; /* 10px 15px */
            }
            .result-day h3 {
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>주간 작업 현황 분석</h1>
        <p>아래 입력창에 주간 작업 정보를 붙여넣고 '인원 현황 확인' 버튼을 눌러주세요.</p>
        <textarea id="taskInput" placeholder="여기에 작업 정보를 붙여넣으세요. (예: &#60;6월 9일 월요일&#62; 여름휴가: 최현철, 노진성...)"></textarea>
        <button onclick="analyzeTasks()">인원 현황 확인</button>
        <div id="results"></div>
        <div class="version-info">
            Version: v1.5
        </div>
    </div>

    <script>
        // 전체 직원 명단 (직급 순서대로 정렬되어야 함)
        const ALL_EMPLOYEES = [
            '이상엽', '서한주', '강범일', '최광섭', '조광호', '최현철', '김진탁', '신재웅', '권용덕', '김태영',
            '노진성', '장다빈', '조용준', '신지호', '최이택', '고상원', '박정민', '박경식', '임영곤', '윤호진'
        ];

        // ALL_EMPLOYEES의 순서를 참조하기 위한 맵 생성
        const employeeOrderMap = new Map();
        ALL_EMPLOYEES.forEach((name, index) => {
            employeeOrderMap.set(name, index);
        });

        // 커스텀 정렬 함수: ALL_EMPLOYEES 순서대로 정렬
        function sortByEmployeeOrder(a, b) {
            const indexA = employeeOrderMap.has(a) ? employeeOrderMap.get(a) : Infinity;
            const indexB = employeeOrderMap.has(b) ? employeeOrderMap.get(b) : Infinity;
            return indexA - indexB;
        }

        function analyzeTasks() {
            const inputText = document.getElementById('taskInput').value;
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = ''; // 이전 결과 초기화

            const lines = inputText.split('\n');
            let currentDay = '';
            // 날짜별 배정/제외 인원 데이터를 저장할 임시 객체
            const dailyData = {}; 

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim(); // 각 줄의 앞뒤 공백 제거

                const dayMatch = line.match(/^<(\d{1,2}월 \d{1,2}일 [월화수목금토일]요일)>/);
                if (dayMatch) {
                    currentDay = dayMatch[1];
                    dailyData[currentDay] = {
                        assigned: new Set(),
                        exclusions: {
                            summerVacation: new Set(),
                            education: new Set(),
                            civilDefense: new Set(),
                            other: new Set()
                        }
                    };
                    // 날짜 라인 뒤에 오는 특별 사유 처리 (현재 줄의 다음 줄 확인)
                    if (i + 1 < lines.length) {
                        const nextLine = lines[i + 1].trim();
                        const exclusionMatch = nextLine.match(/^(여름휴가|교육|민방위):\s*(.+)/);
                        if (exclusionMatch) {
                            const reason = exclusionMatch[1];
                            const employees = exclusionMatch[2].split(',').map(name => name.trim());
                            employees.forEach(employee => {
                                if (reason === '여름휴가') dailyData[currentDay].exclusions.summerVacation.add(employee);
                                else if (reason === '교육') dailyData[currentDay].exclusions.education.add(employee);
                                else if (reason === '민방위') dailyData[currentDay].exclusions.civilDefense.add(employee);
                                else dailyData[currentDay].exclusions.other.add(employee);
                            });
                            i++; // 다음 줄은 이미 처리했으므로 한 줄 건너뜀
                            continue; // 현재 날짜 라인 처리 후 다음 루프로
                        }
                    }
                }

                if (currentDay) {
                    // 작업자 추출 (■ 로 시작하는 라인)
                    const workerMatch = line.match(/^■.+?\/ (.+?)(?:\s*\(현업PO_UR|\s*\(현업PO|\s*\n|$)/);
                    if (workerMatch && workerMatch[1]) {
                        workerMatch[1].split(',').forEach(worker => {
                            dailyData[currentDay].assigned.add(worker.trim());
                        });
                    }
                }
            }


            // 결과 계산 및 표시
            const sortedDays = Object.keys(dailyData).sort((a, b) => {
                const getDate = (dayStr) => {
                    const parts = dayStr.match(/(\d{1,2})월 (\d{1,2})일/);
                    if (!parts) return 0;
                    const currentYear = new Date().getFullYear();
                    return new Date(currentYear, parseInt(parts[1]) - 1, parseInt(parts[2])).getTime();
                };
                return getDate(a) - getDate(b);
            });

            if (sortedDays.length === 0) {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #e74c3c;">분석할 작업 정보가 없습니다. 올바른 형식으로 붙여넣어 주세요.</p>';
                return;
            }

            sortedDays.forEach(day => {
                const assignedWorkers = dailyData[day].assigned;
                const excludedByReason = dailyData[day].exclusions;
                const allOccupiedWorkers = new Set(); 

                // 작업 배정 인원 추가
                assignedWorkers.forEach(worker => allOccupiedWorkers.add(worker));

                // 사유별 제외 인원 추가 및 HTML 생성
                let excludedReasonsHtml = '';
                const tempExcludedList = []; // 사유 불문 모든 제외 인원 임시 저장
                
                if (excludedByReason.summerVacation.size > 0) {
                    Array.from(excludedByReason.summerVacation).forEach(worker => {
                        allOccupiedWorkers.add(worker);
                        tempExcludedList.push({ name: worker, reason: '여름휴가' });
                    });
                }
                if (excludedByReason.education.size > 0) {
                    Array.from(excludedByReason.education).forEach(worker => {
                        allOccupiedWorkers.add(worker);
                        tempExcludedList.push({ name: worker, reason: '교육' });
                    });
                }
                if (excludedByReason.civilDefense.size > 0) {
                    Array.from(excludedByReason.civilDefense).forEach(worker => {
                        allOccupiedWorkers.add(worker);
                        tempExcludedList.push({ name: worker, reason: '민방위' });
                    });
                }
                // 기타 제외 인원 (현재 형식에서는 없지만 확장성 고려)
                if (excludedByReason.other.size > 0) {
                    Array.from(excludedByReason.other).forEach(worker => {
                        allOccupiedWorkers.add(worker);
                        tempExcludedList.push({ name: worker, reason: '기타 제외' });
                    });
                }

                // 제외 인원들을 사유와 함께 직급 순서로 정렬하여 HTML로 표시
                const sortedSpecialExcludedWorkers = tempExcludedList.sort((a, b) => sortByEmployeeOrder(a.name, b.name));
                if (sortedSpecialExcludedWorkers.length > 0) {
                    excludedReasonsHtml = `<p><strong>휴가/교육/민방위 인원 (${sortedSpecialExcludedWorkers.length}명):</strong></p><div class="employee-list">`;
                    sortedSpecialExcludedWorkers.forEach(item => {
                        let reasonText = '';
                        if (item.reason === '여름휴가') reasonText = ' (휴가)';
                        else if (item.reason === '교육') reasonText = ' (교육)';
                        else if (item.reason === '민방위') reasonText = ' (민방위)';
                        else reasonText = ` (${item.reason})`; // 기타 사유
                        excludedReasonsHtml += `<span class="employee-tag excluded-tag">${item.name}${reasonText}</span>`;
                    });
                    excludedReasonsHtml += `</div>`;
                } else {
                    excludedReasonsHtml = '<p><strong>휴가/교육/민방위 인원:</strong> <span class="no-one">없음</span></p>';
                }


                const remainingWorkers = new Set(ALL_EMPLOYEES);
                allOccupiedWorkers.forEach(worker => remainingWorkers.delete(worker));

                // 명단 정렬 (직급 순서)
                const sortedAssignedWorkers = Array.from(assignedWorkers).sort(sortByEmployeeOrder);
                const sortedRemainingWorkers = Array.from(remainingWorkers).sort(sortByEmployeeOrder);

                const assignedListHtml = sortedAssignedWorkers.length > 0
                    ? sortedAssignedWorkers.map(worker => `<span class="employee-tag assigned-tag">${worker}</span>`).join('')
                    : '<span class="no-one">작업 배정된 인원 없음</span>';

                const remainingListHtml = sortedRemainingWorkers.length > 0
                    ? sortedRemainingWorkers.map(worker => `<span class="employee-tag remaining-tag">${worker}</span>`).join('')
                    : '<span class="no-one">남는 인원이 없습니다.</span>';

                const resultHtml = `
                    <div class="result-day">
                        <h3>${day}</h3>
                        ${excludedReasonsHtml}
                        <p><strong>작업 배정 인원 (${sortedAssignedWorkers.length}명):</strong></p>
                        <div class="employee-list">
                            ${assignedListHtml}
                        </div>
                        <p><strong>남는 인원 (${sortedRemainingWorkers.length}명):</strong></p>
                        <div class="employee-list">
                            ${remainingListHtml}
                        </div>
                    </div>
                `;
                resultsDiv.innerHTML += resultHtml;
            });
        }
    </script>
</body>
</html>
