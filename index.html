<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>인원 현황판</title>
    <style>
        /* 기본 HTML 요소 스타일 초기화 및 설정 */
        html {
            font-size: 16px; /* 1rem의 기준 설정 */
        }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            padding: 1.25rem; /* 20px */
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
        }

        /* 컨테이너: 최대 너비를 제한하고 중앙 정렬 */
        .container {
            max-width: 50rem; /* 800px */
            margin: 0 auto;
            background-color: #fff;
            padding: 1.5625rem; /* 25px */
            border-radius: 0.625rem; /* 10px */
            box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.1); /* 0 4px 8px */
        }

        /* 제목 및 설명 텍스트 */
        h1 { 
            color: #2c3e50; 
            text-align: center; 
            margin-bottom: 1.5625rem; /* 25px */
            font-size: 1.8em; /* 부모 글꼴 크기의 1.8배 */
        }
        p {
            text-align: center;
            color: #555;
            margin-bottom: 1.25rem; /* 20px */
        }

        /* 텍스트 입력창 */
        textarea { 
            width: calc(100% - 0.625rem * 2); /* 100% - padding * 2 */
            height: 15.625rem; /* 250px */
            margin-bottom: 0.9375rem; /* 15px */
            padding: 0.625rem; /* 10px */
            border: 0.0625rem solid #ccc; /* 1px */
            border-radius: 0.3125rem; /* 5px */
            font-size: 0.95em; /* 부모 글꼴 크기의 0.95배 */
            resize: vertical; /* 세로 크기 조절 허용 */
            box-sizing: border-box; /* 패딩이 너비에 포함되도록 */
        }

        /* 버튼 */
        button { 
            display: block;
            width: 100%;
            padding: 0.75rem 1.25rem; /* 12px 20px */
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 0.3125rem; /* 5px */
            font-size: 1.1em; /* 부모 글꼴 크기의 1.1배 */
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #2980b9;
        }

        /* 결과 표시 영역 - 요일별 섹션 */
        .result-day { 
            margin-top: 1.5625rem; /* 25px */
            padding: 0.9375rem; /* 15px */
            background-color: #ecf0f1;
            border-left: 0.3125rem solid #3498db; /* 5px */
            border-radius: 0.3125rem; /* 5px */
        }
        .result-day h3 { 
            margin-top: 0; 
            color: #2c3e50;
            font-size: 1.4em; /* 부모 글꼴 크기의 1.4배 */
            margin-bottom: 0.625rem; /* 10px */
        }
        .result-day p strong {
            color: #555;
        }

        /* 직원 태그 목록 */
        .employee-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem; /* 8px */
            margin-top: 0.625rem; /* 10px */
            margin-bottom: 0.9375rem; /* 15px */
            padding-left: 0; 
        }
        .employee-tag {
            background-color: #bdc3c7;
            color: #333;
            padding: 0.375rem 0.625rem; /* 6px 10px */
            border-radius: 0.25rem; /* 4px */
            font-size: 0.85em; /* 부모 글꼴 크기의 0.85배 */
            white-space: nowrap; /* 태그가 줄바꿈되지 않도록 */
        }
        .assigned-tag {
            background-color: #2ecc71; /* 배정된 인원 색상 */
            color: white;
        }
        .remaining-tag {
            background-color: #3498db; /* 남는 인원 색상 */
            color: white;
        }
        .no-one {
            color: #e74c3c;
            font-style: italic;
        }

        /* 버전 정보 */
        .version-info {
            text-align: center;
            margin-top: 1.875rem; /* 30px */
            font-size: 0.8em; /* 부모 글꼴 크기의 0.8배 */
            color: #7f8c8d;
        }

        /* 모바일 최적화를 위한 미디어 쿼리 (특정 해상도에서 추가 조정) */
        @media (max-width: 37.5rem) { /* 600px */
            body {
                padding: 0.9375rem; /* 15px */
            }
            .container {
                padding: 0.9375rem; /* 15px */
            }
            h1 {
                font-size: 1.5em;
            }
            textarea {
                height: 12.5rem; /* 200px */
            }
            button {
                font-size: 1em;
                padding: 0.625rem 0.9375rem; /* 10px 15px */
            }
            .result-day h3 {
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>주간 작업 현황 분석</h1>
        <p>아래 입력창에 주간 작업 정보를 붙여넣고 '인원 현황 확인' 버튼을 눌러주세요.</p>
        <textarea id="taskInput" placeholder="여기에 작업 정보를 붙여넣으세요. (예: &#60;6월 9일 월요일&#62; 여름휴가: 최현철, 노진성...)"></textarea>
        <button onclick="analyzeTasks()">인원 현황 확인</button>
        <div id="results"></div>
        <div class="version-info">
            Version: v2.3
        </div>
    </div>

    <script>
        // 전체 직원 명단 (직급 순서대로 정렬되어야 함)
        const ALL_EMPLOYEES = [
            '이상엽', '서한주', '강범일', '최광섭', '조광호', '최현철', '김진탁', '신재웅', '권용덕', '김태영',
            '노진성', '장다빈', '조용준', '신지호', '최이택', '고상원', '박정민', '박경식', '임영곤', '윤호진'
        ];

        // ALL_EMPLOYEES의 순서를 참조하기 위한 맵 생성
        const employeeOrderMap = new Map();
        ALL_EMPLOYEES.forEach((name, index) => {
            employeeOrderMap.set(name, index);
        });

        // 커스텀 정렬 함수: ALL_EMPLOYEES 순서대로 정렬
        function sortByEmployeeOrder(a, b) {
            const indexA = employeeOrderMap.has(a) ? employeeOrderMap.get(a) : Infinity;
            const indexB = employeeOrderMap.has(b) ? employeeOrderMap.get(b) : Infinity;
            return indexA - indexB;
        }

        function analyzeTasks() {
            const inputText = document.getElementById('taskInput').value;
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = ''; // 이전 결과 초기화

            const lines = inputText.split('\n');
            let currentDay = null; // 현재 처리 중인 요일
            const dailyAssignedWorkers = {}; // { '6월 9일 월요일': Set<직원명>, ... }

            // 각 줄을 반복하며 파싱
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim(); // 각 줄의 앞뒤 공백 제거

                // 빈 줄이거나 주간 요약 줄은 무시 (맨 위 한 줄은 건너뛸 필요 없음, regex로 처리)
                if (line === '' || line.startsWith('▣')) { 
                    continue;
                }

                // 1. 날짜 라인 확인 (새로운 요일 블록의 시작)
                const dayMatch = line.match(/^<(\d{1,2}월 \d{1,2}일 [월화수목금토일]요일)>/);
                if (dayMatch) {
                    currentDay = dayMatch[1]; // 현재 요일 설정
                    dailyAssignedWorkers[currentDay] = new Set(); // 해당 요일의 할당된 인원 Set 초기화
                    
                    // 핵심 로직: 날짜 라인 바로 다음 줄에 사유(여름휴가 등)가 있는지 확인하고 처리
                    if (i + 1 < lines.length) {
                        const nextLine = lines[i + 1].trim();
                        const specialCaseMatch = nextLine.match(/^(?:여름휴가|교육|민방위|연차|반차|병가):\s*(.+)/);
                        if (specialCaseMatch && specialCaseMatch[2]) {
                            specialCaseMatch[2].split(',').forEach(worker => {
                                dailyAssignedWorkers[currentDay].add(worker.trim());
                            });
                            i++; // 다음 줄(사유 줄)은 이미 처리했으므로 한 줄 건너뜀
                        }
                    }
                    continue; // 날짜 라인 처리 완료, 다음 줄로 넘어감
                }

                // 현재 요일이 설정된 후에만 작업자 파싱 로직 실행
                if (currentDay) {
                    // 2. '■ ... / 작업자' 패턴에서 작업자 추출
                    const workerMatch = line.match(/^■.+?\/ (.+?)(?:\s*\(현업PO_UR|\s*\(현업PO|\s*\n|$)/);
                    if (workerMatch && workerMatch[1]) {
                        workerMatch[1].split(',').forEach(worker => {
                            dailyAssignedWorkers[currentDay].add(worker.trim());
                        });
                        continue; // 작업자 라인 처리 완료, 다음 줄로 넘어감
                    }
                    
                    // 3. (혹시 모를) 다른 위치의 '사유: 인원' 패턴에서 인원 추출
                    // 이 부분은 날짜 바로 뒤에 오는 사유 줄이 아닌, 중간에 끼어있는 사유 줄을 위함입니다.
                    const otherSpecialCaseMatch = line.match(/^(?:여름휴가|교육|민방위|연차|반차|병가):\s*(.+)/);
                    if (otherSpecialCaseMatch && otherSpecialCaseMatch[2]) {
                         otherSpecialCaseMatch[2].split(',').forEach(worker => {
                            dailyAssignedWorkers[currentDay].add(worker.trim());
                        });
                    }
                }
            }


            // 결과 계산 및 표시
            const sortedDays = Object.keys(dailyAssignedWorkers).sort((a, b) => {
                const getDate = (dayStr) => {
                    const parts = dayStr.match(/(\d{1,2})월 (\d{1,2})일/);
                    if (!parts) return 0;
                    const currentYear = new Date().getFullYear(); 
                    return new Date(currentYear, parseInt(parts[1]) - 1, parseInt(parts[2])).getTime();
                };
                return getDate(a) - getDate(b);
            });

            if (sortedDays.length === 0) {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #e74c3c;">분석할 작업 정보가 없습니다. 올바른 형식으로 붙여넣어 주세요.</p>';
                return;
            }

            sortedDays.forEach(day => {
                const assignedWorkers = dailyAssignedWorkers[day];
                const remainingWorkers = new Set(ALL_EMPLOYEES);

                // ALL_EMPLOYEES에서 해당 요일의 '작업 배정 인원' (텍스트에 언급된 모든 인원) 제거
                assignedWorkers.forEach(worker => remainingWorkers.delete(worker));

                // 명단 정렬 (직급 순서)
                const sortedAssignedList = Array.from(assignedWorkers).sort(sortByEmployeeOrder);
                const sortedRemainingList = Array.from(remainingWorkers).sort(sortByEmployeeOrder);

                const assignedListHtml = sortedAssignedList.length > 0
                    ? sortedAssignedList.map(worker => `<span class="employee-tag assigned-tag">${worker}</span>`).join('')
                    : '<span class="no-one">배정된 인원 없음</span>';

                const remainingListHtml = sortedRemainingList.length > 0
                    ? sortedRemainingList.map(worker => `<span class="employee-tag remaining-tag">${worker}</span>`).join('')
                    : '<span class="no-one">남는 인원이 없습니다.</span>';

                const resultHtml = `
                    <div class="result-day">
                        <h3>${day}</h3>
                        <p><strong>작업 배정 인원 (${sortedAssignedList.length}명):</strong></p>
                        <div class="employee-list">
                            ${assignedListHtml}
                        </div>
                        <p><strong>남는 인원 (${sortedRemainingList.length}명):</strong></p>
                        <div class="employee-list">
                            ${remainingListHtml}
                        </div>
                    </div>
                `;
                resultsDiv.innerHTML += resultHtml;
            });
        }
    </script>
</body>
</html>
